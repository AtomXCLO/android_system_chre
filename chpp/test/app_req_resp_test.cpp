/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <gtest/gtest.h>

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <cstring>
#include <thread>

#include "chpp/app.h"
#include "chpp/clients.h"
#include "chpp/clients/discovery.h"
#include "chpp/macros.h"
#include "chpp/notifier.h"
#include "chpp/platform/platform_link.h"
#include "chpp/platform/utils.h"
#include "chpp/services.h"
#include "chpp/transport.h"
#include "chre/util/enum.h"
#include "chre/util/time.h"

namespace chre {

namespace {

constexpr uint64_t kResetWaitTimeMs = 1500;
constexpr uint64_t kDiscoveryWaitTimeMs = 5000;

void *workThread(void *transportState) {
  ChppTransportState *state = static_cast<ChppTransportState *>(transportState);

  auto linkContext =
      static_cast<struct ChppLinuxLinkState *>(state->linkContext);

  pthread_setname_np(pthread_self(), linkContext->workThreadName);

  chppWorkThreadStart(state);

  return nullptr;
}

#define TEST_UUID                                                           \
  {                                                                         \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
        0x00, 0x00, 0x00, 0x12                                              \
  }

enum class Commands : uint16_t {
  kOk,
  kError,
  kTimeout,
  kLastClientRequest,  // Last client request
};

constexpr uint16_t kNumCommands = asBaseType(Commands::kLastClientRequest);

struct ClientState {
  struct ChppClientState chppClientState;
  struct ChppRequestResponseState rRState[kNumCommands];
  bool okResponseStatus;
  bool errorResponseStatus;
  bool timeoutResponseStatus;
  struct ChppNotifier notifier;
};

bool clientInit(void *clientState, uint8_t handle,
                struct ChppVersion serviceVersion);
void clientDeinit(void *clientState);
enum ChppAppErrorCode clientDispatchResponse(void *clientState, uint8_t *buf,
                                             size_t len);

constexpr struct ChppClient kClient = {
    .descriptor.uuid = TEST_UUID,
    .descriptor.version.major = 1,
    .descriptor.version.minor = 0,
    .descriptor.version.patch = 0,
    .resetNotifierFunctionPtr = nullptr,
    .matchNotifierFunctionPtr = nullptr,
    .responseDispatchFunctionPtr = &clientDispatchResponse,
    .notificationDispatchFunctionPtr = nullptr,
    .initFunctionPtr = &clientInit,
    .deinitFunctionPtr = &clientDeinit,
    .rRStateCount = kNumCommands,
    .minLength = sizeof(struct ChppAppHeader),
};

// Called when a response from a service is received.
enum ChppAppErrorCode clientDispatchResponse(void *clientState, uint8_t *buf,
                                             size_t len) {
  auto state = static_cast<struct ClientState *>(clientState);

  // The response is composed of the app header only.
  if (len != sizeof(ChppAppHeader)) {
    return CHPP_APP_ERROR_NONE;
  }

  auto response = reinterpret_cast<struct ChppAppHeader *>(buf);

  switch (response->command) {
    case asBaseType(Commands::kOk):
      // The response for the kOk command should have a CHPP_APP_ERROR_NONE
      // error.
      state->okResponseStatus = chppClientTimestampResponse(
          &state->chppClientState, &state->rRState[asBaseType(Commands::kOk)],
          response);

      state->okResponseStatus &= response->error == CHPP_APP_ERROR_NONE;
      return CHPP_APP_ERROR_NONE;

    case asBaseType(Commands::kError):
      // The response for the kError command should have a
      // CHPP_APP_ERROR_UNSPECIFIED error.
      state->errorResponseStatus = chppClientTimestampResponse(
          &state->chppClientState,
          &state->rRState[asBaseType(Commands::kError)], response);

      state->errorResponseStatus &=
          response->error == CHPP_APP_ERROR_UNSPECIFIED;
      return CHPP_APP_ERROR_NONE;

    case asBaseType(Commands::kTimeout):
      // The response for the kTimeout command should have a
      // CHPP_APP_ERROR_TIMEOUT error. That response is generated by the app
      // layer.
      state->timeoutResponseStatus = chppClientTimestampResponse(
          &state->chppClientState,
          &state->rRState[asBaseType(Commands::kTimeout)], response);

      state->timeoutResponseStatus &= response->error == CHPP_APP_ERROR_TIMEOUT;
      chppNotifierSignal(&state->notifier, 1 /*signal*/);
      return CHPP_APP_ERROR_NONE;

    default:
      return CHPP_APP_ERROR_NONE;
  }
}

bool clientInit(void *clientState, uint8_t handle,
                struct ChppVersion serviceVersion) {
  UNUSED_VAR(serviceVersion);
  auto state = static_cast<struct ClientState *>(clientState);
  state->chppClientState.openState = CHPP_OPEN_STATE_OPENED;
  chppClientInit(&state->chppClientState, handle);
  return true;
}

void clientDeinit(void *clientState) {
  auto state = static_cast<struct ClientState *>(clientState);
  chppClientDeinit(&state->chppClientState);
  state->chppClientState.openState = CHPP_OPEN_STATE_CLOSED;
}

// Service
struct ServiceState {
  struct ChppServiceState chppServiceState;
  struct ChppRequestResponseState rRState[kNumCommands];
};

// Called when a request is received from the client.
enum ChppAppErrorCode serviceDispatchRequest(void *serviceState, uint8_t *buf,
                                             size_t len) {
  // The request is composed of the app header only.
  if (len != sizeof(ChppAppHeader)) {
    return CHPP_APP_ERROR_NONE;
  }

  auto appHeader = reinterpret_cast<struct ChppAppHeader *>(buf);
  auto state = static_cast<struct ServiceState *>(serviceState);

  switch (appHeader->command) {
    case asBaseType(Commands::kOk): {
      // Return a response for the kOk command.
      chppServiceTimestampRequest(&state->rRState[asBaseType(Commands::kOk)],
                                  appHeader);

      struct ChppAppHeader *response =
          chppAllocServiceResponse(appHeader, sizeof(ChppAppHeader));

      chppSendTimestampedResponseOrFail(
          &state->chppServiceState, &state->rRState[asBaseType(Commands::kOk)],
          response, sizeof(ChppAppHeader));
      return CHPP_APP_ERROR_NONE;
    }
    case asBaseType(Commands::kError): {
      // Return a response with a CHPP_APP_ERROR_UNSPECIFIED error on kError
      // command.
      chppServiceTimestampRequest(&state->rRState[asBaseType(Commands::kError)],
                                  appHeader);

      struct ChppAppHeader *response =
          chppAllocServiceResponse(appHeader, sizeof(ChppAppHeader));

      response->error = CHPP_APP_ERROR_UNSPECIFIED;

      chppSendTimestampedResponseOrFail(
          &state->chppServiceState,
          &state->rRState[asBaseType(Commands::kError)], response,
          sizeof(ChppAppHeader));
      return CHPP_APP_ERROR_NONE;
    }

    case asBaseType(Commands::kTimeout): {
      // Do not send a response on kTimeout for the client to timeout.
      chppServiceTimestampRequest(&state->rRState[asBaseType(Commands::kError)],
                                  appHeader);

      return CHPP_APP_ERROR_NONE;
    }

    default:
      return CHPP_APP_ERROR_NONE;
  }
}

const struct ChppService kService = {
    .descriptor.uuid = TEST_UUID,
    .descriptor.name = "Test",
    .descriptor.version.major = 1,
    .descriptor.version.minor = 0,
    .descriptor.version.patch = 0,
    .resetNotifierFunctionPtr = nullptr,
    .requestDispatchFunctionPtr = &serviceDispatchRequest,
    .notificationDispatchFunctionPtr = nullptr,
    .minLength = sizeof(struct ChppAppHeader),
};

// Test requests and responses.
class AppReqRespTest : public testing::Test {
 protected:
  void SetUp() {
    chppClearTotalAllocBytes();
    chppNotifierInit(&mClientState.notifier);
    memset(&mClientLinkContext, 0, sizeof(mClientLinkContext));
    memset(&mServiceLinkContext, 0, sizeof(mServiceLinkContext));

    mServiceLinkContext.linkThreadName = "Host Link";
    mServiceLinkContext.workThreadName = "Host worker";
    mServiceLinkContext.isLinkActive = true;
    mServiceLinkContext.remoteLinkState = &mClientLinkContext;
    mServiceLinkContext.rxInRemoteEndpointWorker = false;

    mClientLinkContext.linkThreadName = "CHRE Link";
    mClientLinkContext.workThreadName = "CHRE worker";
    mClientLinkContext.isLinkActive = true;
    mClientLinkContext.remoteLinkState = &mServiceLinkContext;
    mClientLinkContext.rxInRemoteEndpointWorker = false;

    // No default clients/services.
    struct ChppClientServiceSet set;
    memset(&set, 0, sizeof(set));

    const struct ChppLinkApi *linkApi = getLinuxLinkApi();

    // Init client side.
    chppTransportInit(&mClientTransportContext, &mClientAppContext,
                      &mClientLinkContext, linkApi);
    chppAppInitWithClientServiceSet(&mClientAppContext,
                                    &mClientTransportContext, set);

    // Init service side.
    chppTransportInit(&mServiceTransportContext, &mServiceAppContext,
                      &mServiceLinkContext, linkApi);
    chppAppInitWithClientServiceSet(&mServiceAppContext,
                                    &mServiceTransportContext, set);

    BringUpClient();
    std::this_thread::sleep_for(std::chrono::milliseconds(450));
    BringUpService();
    mClientLinkContext.linkEstablished = true;
    mServiceLinkContext.linkEstablished = true;

    chppTransportWaitForResetComplete(&mClientTransportContext,
                                      kResetWaitTimeMs);
    chppWaitForDiscoveryComplete(&mClientAppContext, kDiscoveryWaitTimeMs);
    chppWaitForDiscoveryComplete(&mServiceAppContext, kDiscoveryWaitTimeMs);
  }

  void BringUpClient() {
    memset(&mClientState, 0, sizeof(mClientState));
    chppRegisterClient(&mClientAppContext, &mClientState,
                       &mClientState.chppClientState, &mClientState.rRState[0],
                       &kClient);

    pthread_create(&mClientWorkThread, NULL, workThread,
                   &mClientTransportContext);
  }

  void BringUpService() {
    memset(&mServiceState, 0, sizeof(mServiceState));
    chppRegisterService(&mServiceAppContext, &mServiceState,
                        &mServiceState.chppServiceState, &kService);

    pthread_create(&mServiceWorkThread, NULL, workThread,
                   &mServiceTransportContext);
  }

  void TearDown() {
    chppNotifierDeinit(&mClientState.notifier);
    chppWorkThreadStop(&mClientTransportContext);
    chppWorkThreadStop(&mServiceTransportContext);
    pthread_join(mClientWorkThread, NULL);
    pthread_join(mServiceWorkThread, NULL);

    // Deinit client side.
    chppAppDeinit(&mClientAppContext);
    chppTransportDeinit(&mClientTransportContext);

    // Deinit service side.
    chppAppDeinit(&mServiceAppContext);
    chppTransportDeinit(&mServiceTransportContext);

    EXPECT_EQ(chppGetTotalAllocBytes(), 0);
  }

  // Client side.
  ChppLinuxLinkState mClientLinkContext = {};
  ChppTransportState mClientTransportContext = {};
  ChppAppState mClientAppContext = {};
  pthread_t mClientWorkThread;
  ClientState mClientState;

  // Service side
  ChppLinuxLinkState mServiceLinkContext = {};
  ChppTransportState mServiceTransportContext = {};
  ChppAppState mServiceAppContext = {};
  pthread_t mServiceWorkThread;
  ServiceState mServiceState;
};

TEST_F(AppReqRespTest, clientSendsRequestAndReceiveResponse) {
  // Send a request.
  constexpr size_t requestLen = sizeof(struct ChppAppHeader);
  struct ChppAppHeader *request =
      chppAllocClientRequest(&mClientState.chppClientState, requestLen);
  ASSERT_NE(request, nullptr);
  request->command = asBaseType(Commands::kOk);

  mClientState.okResponseStatus = false;

  EXPECT_TRUE(chppSendTimestampedRequestAndWait(
      &mClientState.chppClientState,
      &mClientState.rRState[asBaseType(Commands::kOk)], request, requestLen));

  EXPECT_TRUE(mClientState.okResponseStatus);
}

TEST_F(AppReqRespTest, clientSendsRequestAndReceiveErrorResponse) {
  // Send a request.
  constexpr size_t requestLen = sizeof(struct ChppAppHeader);
  struct ChppAppHeader *request =
      chppAllocClientRequest(&mClientState.chppClientState, requestLen);
  ASSERT_NE(request, nullptr);
  request->command = asBaseType(Commands::kError);

  mClientState.errorResponseStatus = false;

  EXPECT_TRUE(chppSendTimestampedRequestAndWait(
      &mClientState.chppClientState,
      &mClientState.rRState[asBaseType(Commands::kError)], request,
      requestLen));

  EXPECT_TRUE(mClientState.errorResponseStatus);
}

TEST_F(AppReqRespTest, clientSendsRequestAndReceiveTimeoutResponse) {
  // Send a request.
  constexpr size_t requestLen = sizeof(struct ChppAppHeader);
  struct ChppAppHeader *request =
      chppAllocClientRequest(&mClientState.chppClientState, requestLen);
  ASSERT_NE(request, nullptr);
  request->command = asBaseType(Commands::kTimeout);

  mClientState.timeoutResponseStatus = false;

  EXPECT_TRUE(chppSendTimestampedRequestOrFail(
      &mClientState.chppClientState,
      &mClientState.rRState[asBaseType(Commands::kTimeout)], request,
      requestLen, 10 * kOneMicrosecondInNanoseconds /*timeoutNs*/));

  chppNotifierWait(&mClientState.notifier);

  EXPECT_TRUE(mClientState.timeoutResponseStatus);
}

}  // namespace

}  // namespace chre